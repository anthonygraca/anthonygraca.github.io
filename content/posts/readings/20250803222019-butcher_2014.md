+++
title = "butcher-2014"
author = ["Anthony Graca"]
date = 2025-08-03T22:20:00-07:00
tags = ["Bibliography"]
draft = false
+++

## Citation {#citation}

```tex
@book{butcher2014,
  title={Seven Concurrency Models in Seven Weeks: When Threads Unravel},
  author={Butcher, Paul},
  year={2014},
  publisher={The Pragmatic Bookshelf}
}
```


## Summary. What are the statements being made? {#summary-dot-what-are-the-statements-being-made}


## 1. Introduction {#1-dot-introduction}


### Concurrent or Parallel? {#concurrent-or-parallel}

-   Concurrent and parallel refer to two related but different things
-   "A _concurrent_ program has multiple logical _threads of control_. These threads may or may not run in parallel (Butcher 2014, 1)."
-   "A _parallel_ program potentially runs more quickly than a sequential program by executing different parts of the computation simultaneously in parallel. It may or may not have more than one logical thread of control"


### Parallel Architecture {#parallel-architecture}


### Concurrency: Beyond Multiple Cores {#concurrency-beyond-multiple-cores}


### The Seven Models {#the-seven-models}


## 2. Threads and Locks {#2-dot-threads-and-locks}

-   p 9


### The Simplest Thing that Could Possibly Work {#the-simplest-thing-that-could-possibly-work}


### Day 1: Mutual Exclusion and Memory Models {#day-1-mutual-exclusion-and-memory-models}


### Day 2: Beyond Intrinsic Locks {#day-2-beyond-intrinsic-locks}


### Day 3: On the Shoulders of Giants {#day-3-on-the-shoulders-of-giants}


## 3. Functional Programming {#3-dot-functional-programming}

-   p 49


### If it Hurts, Stop Doing It {#if-it-hurts-stop-doing-it}


### Day 1: Programming Without Mutable State {#day-1-programming-without-mutable-state}


### Day 2: Functional Parallelism {#day-2-functional-parallelism}


### Day 3: Functional Concurrency {#day-3-functional-concurrency}


## 4. The Clojure Way - Separating Identity from State {#4-dot-the-clojure-way-separating-identity-from-state}

-   p 85


### The Best of Both Worlds {#the-best-of-both-worlds}


### Day 1: Atoms and Persistent Data Structures {#day-1-atoms-and-persistent-data-structures}


### Day 2: Agents and Software Transactional memory {#day-2-agents-and-software-transactional-memory}


### Day 3: In Depth {#day-3-in-depth}


## 5. Actors {#5-dot-actors}

-   p 115


### More Object-Oriented than Objects {#more-object-oriented-than-objects}


### Day 1: Messages and Mailboxes {#day-1-messages-and-mailboxes}


### Day 2: Error Handling and Resilience {#day-2-error-handling-and-resilience}


### Day 3: Distribution {#day-3-distribution}


## 6. Communicating Sequential Processes {#6-dot-communicating-sequential-processes}

-   p 153


### Communication Is Everything {#communication-is-everything}


### Day 1: Channels and Go Blocks {#day-1-channels-and-go-blocks}


### Day 2: Multiple Channels and IO {#day-2-multiple-channels-and-io}


### Day 3: Client-Side CSP {#day-3-client-side-csp}


## 7. Data Parallelism {#7-dot-data-parallelism}

-   p 189


### The Supercomputer Hidden in Your Laptop {#the-supercomputer-hidden-in-your-laptop}


### Day 1: GPGPU Programming {#day-1-gpgpu-programming}


### Day 2: multiple Dimensions and Work-Groups {#day-2-multiple-dimensions-and-work-groups}


### Day 3: OpenCL and OpenGL - Keeping it on the GPU {#day-3-opencl-and-opengl-keeping-it-on-the-gpu}


## 8. The Lambda Architecture {#8-dot-the-lambda-architecture}

-   p 223


### Parallelism Enables Big Data {#parallelism-enables-big-data}


### Day 1: MapReduce {#day-1-mapreduce}


### Day 2: The Batch Layer {#day-2-the-batch-layer}


### Day 3: The Speed Layer {#day-3-the-speed-layer}


## 9. Wrapping Up {#9-dot-wrapping-up}

-   p 263


## Next {#next}

-   [tate-2010]({{< relref "20250803223046-tate_2010.md" >}})
