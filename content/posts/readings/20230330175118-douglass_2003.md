+++
title = "douglass-2003"
author = ["Anthony Graca"]
date = 2023-03-30T17:51:00-07:00
tags = ["Bibliography"]
draft = false
+++

## Citation {#citation}

-   Author: Bruce Powel Douglass
-   Date Published: 2003
-   Title: Real-Time Design Patterns: Robust Scalable Architecture for Real-Time Systems
-   Source (url, publisher name, or doi): Addison-Wesley


## Foreword {#foreword}

-   by Doug Jensen, Prof of CS at Carnegie Mellon for 8 years.
    -   30 years working in military and industrial real-time computing
    -   Works at MITRE corporation which does research on real-time computing systems for strategic national interest
-   References [lea-1994]({{< relref "20231201152914-lea_1994.md" >}})
-   "Software patterns and UML enable potentially lower software costs in many systems (xiii)"
-   Real-time systems span the entire range of complexity and costs
    -   first case: hardware costs so much more than software costs, like software in laser gyroscope
    -   second case: software is so large and complex that it dwarfs hardware costs, like military or commercial aircraft
-   "Historically, developers of real-time software have lagged behind many other developers in using the most contemporary software engineering methodologies. There are several reasons for this."
    -   "One is that some real-time software is so simple that the most elementary methodologies are needed"
    -   "A more common reason is that many real-time systems with non-trivial software suffer from hardware capacity constraints (due to size, weight, power, and so on). Software structured for purposes such as re-usability, modularity, or flexibility does tend to consume additional time or space resources"
    -   "Yet another reason is that real-time software practitioners are frequently application experts who are not always educated enough in modern software engineering to understand and employ it properly (xiv)"
-   Knowing patterns + UML allows us to build larger scale projects, more dynamic and complex, and more distributed real-time computing systems


## Preface {#preface}

-   "Real time and embedded (RTE) systems must execute in a much more constrained environment than desktop computers (xvii)"
    -   Must be highly efficient to optimized for limited processor and memory resources.
    -   but must also outperform systems with significantly more compute power
    -   RTE have safety-critical and high-reliability requirements
        -   Avionics flight control, nuclear power plant control, life support and medical instrumentation.
-   The best developers with decades of experience encounter the same problems over and over.
    -   These problems are abstracted and their solutions generalized into design patterns
-   This book focuses on practical development rather than theoretical


## Part I: Design Pattern Basics {#part-i-design-pattern-basics}

-   UML is related to architecture.
-   Two types of architecture: logical and physical


## Chapter 1: Introduction - review of UML {#chapter-1-introduction-review-of-uml}


## Chapter 2: Architecture and the UML - defines ROPES {#chapter-2-architecture-and-the-uml-defines-ropes}


## Chapter 3: The Role of Design Patterns {#chapter-3-the-role-of-design-patterns}

-   explains design patterns and their role in defining architecture
    -   Introduces how design patterns could be effectively discussed in a software development process


## Part II: Architectural Design Patterns {#part-ii-architectural-design-patterns}


## Chapter 4: Subsystem and Component Architecture Patterns {#chapter-4-subsystem-and-component-architecture-patterns}


## Chapter 5: Concurrency Patterns {#chapter-5-concurrency-patterns}

-   p 203


### 5.1 Introduction {#5-dot-1-introduction}


### 5.2 Concurrency Pattern {#5-dot-2-concurrency-pattern}


### 5.3 Message Queuing Pattern {#5-dot-3-message-queuing-pattern}


### 5.4 Interrupt Pattern {#5-dot-4-interrupt-pattern}


### 5.5 Guarded Call Pattern {#5-dot-5-guarded-call-pattern}


### 5.6 Rendezvous Pattern {#5-dot-6-rendezvous-pattern}


### 5.7 Cyclic Executive Pattern {#5-dot-7-cyclic-executive-pattern}


### 5.8 Round Robin Pattern {#5-dot-8-round-robin-pattern}


### 5.9 Static Priority Pattern {#5-dot-9-static-priority-pattern}


### 5.10 Dynamic Priority Pattern {#5-dot-10-dynamic-priority-pattern}


## Chapter 6: Memory Patterns {#chapter-6-memory-patterns}

-   p 259


### 6.1 Memory Management Patterns {#6-dot-1-memory-management-patterns}

-   p 260


### 6.2 Static Allocation Pattern: Allocate memory up front {#6-dot-2-static-allocation-pattern-allocate-memory-up-front}


### 6.3 Pool Allocation Pattern: Preallocate pools of needed objects {#6-dot-3-pool-allocation-pattern-preallocate-pools-of-needed-objects}

-   p 266


### 6.4 Fixed Sized Buffer Pattern: Allocates memory in same-sized blocks {#6-dot-4-fixed-sized-buffer-pattern-allocates-memory-in-same-sized-blocks}

-   p 273


### 6.5 Smart Pointer Pattern: Makes pointers reliable {#6-dot-5-smart-pointer-pattern-makes-pointers-reliable}

-   p 278


### 6.6 Garbage Collection Pattern: Automatically reclaims lost memory {#6-dot-6-garbage-collection-pattern-automatically-reclaims-lost-memory}

-   p 286


### 6.7 Garbage Compactor Pattern: Automatically defragments and reclaims memory {#6-dot-7-garbage-compactor-pattern-automatically-defragments-and-reclaims-memory}

-   p 293


## Chapter 7: Resource Patterns {#chapter-7-resource-patterns}

-   p 301


### 7.1 Introduction {#7-dot-1-introduction}


### 7.2 Critical Section Pattern {#7-dot-2-critical-section-pattern}

-   p 308


### 7.3 Priority Inheritance Pattern {#7-dot-3-priority-inheritance-pattern}

-   p 314


### 7.4 Highest Locker Pattern {#7-dot-4-highest-locker-pattern}

-   p 323


### 7.5 Priority Ceiling Pattern {#7-dot-5-priority-ceiling-pattern}

-   p 330


### 7.6 Simultaneous Locking Pattern {#7-dot-6-simultaneous-locking-pattern}

-   p 338


### 7.7 Ordered Locking Pattern {#7-dot-7-ordered-locking-pattern}

-   p 345


## Chapter 8: Distribution Patterns - distributed computing {#chapter-8-distribution-patterns-distributed-computing}


### 8.1 Introduction {#8-dot-1-introduction}

-   p 354


### 8.2 Shared Memory Pattern {#8-dot-2-shared-memory-pattern}

-   p 356


### 8.3 Remote Method Call Pattern {#8-dot-3-remote-method-call-pattern}

-   p 362


### 8.4 Observer Pattern {#8-dot-4-observer-pattern}

-   p 370


### 8.5 Data Bus Pattern {#8-dot-5-data-bus-pattern}

-   p 377


### 8.6 Proxy Pattern {#8-dot-6-proxy-pattern}

-   p 387


### 8.7 Broker Pattern {#8-dot-7-broker-pattern}

-   p 395


## Chapter 9: Safety and Reliability Patterns {#chapter-9-safety-and-reliability-patterns}


### 9.1 Introduction {#9-dot-1-introduction}

-   p 405


#### 9.1.1 Handling Faults {#9-dot-1-dot-1-handling-faults}


### 9.2 Protected Single Channel Pattern {#9-dot-2-protected-single-channel-pattern}

-   p 409


### 9.3 Homogeneous Redundancy Pattern {#9-dot-3-homogeneous-redundancy-pattern}

-   p 415


### 9.4 Triple Modular Redundancy Pattern {#9-dot-4-triple-modular-redundancy-pattern}

-   p 421


### 9.5 Heterogeneous Redundancy Pattern {#9-dot-5-heterogeneous-redundancy-pattern}

-   p 426


### 9.6 Monitor-Actuator Pattern {#9-dot-6-monitor-actuator-pattern}

-   p 432


### 9.7 Sanity Check Pattern {#9-dot-7-sanity-check-pattern}

-   p 438


### 9.8 Watchdog Pattern {#9-dot-8-watchdog-pattern}

-   p 443


### 9.9 Safety Executive Pattern {#9-dot-9-safety-executive-pattern}

-   p 450
