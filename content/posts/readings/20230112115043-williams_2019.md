+++
title = "williams-2019"
author = ["Anthony Graca"]
date = 2023-01-12T11:50:00-08:00
tags = ["Bibliography"]
draft = false
+++

## Citation {#citation}

-   Author: Anthony Williams
-   Date Published: 2019
-   Title: C++ Concurrency in Action, Second Edition
-   Source (url, publisher name, or doi): Manning


## Ch 1 - Hello, world of concurrency in C++! {#ch-1-hello-world-of-concurrency-in-c-plus-plus}


### 1.1 What is concurrency? {#1-dot-1-what-is-concurrency}


### 1.2 Why use concurrency? {#1-dot-2-why-use-concurrency}


### 1.3 Concurrency and multithreading in C++ {#1-dot-3-concurrency-and-multithreading-in-c-plus-plus}


### 1.4 Getting started {#1-dot-4-getting-started}


## Ch 2 - Managing threads {#ch-2-managing-threads}


### 2.1 Basic thread management {#2-dot-1-basic-thread-management}


#### Launching a thread {#launching-a-thread}


#### Waiting for a thread to complete {#waiting-for-a-thread-to-complete}


#### Waiting in exceptional circumstances {#waiting-in-exceptional-circumstances}


#### Running threads in the background {#running-threads-in-the-background}


### 2.2 Passing arguments to a thread function {#2-dot-2-passing-arguments-to-a-thread-function}


### 2.3 Transferring ownership of a thread {#2-dot-3-transferring-ownership-of-a-thread}


### 2.4 Choosing the number of threads at runtime {#2-dot-4-choosing-the-number-of-threads-at-runtime}


### 2.5 Identifying threads {#2-dot-5-identifying-threads}


## Ch 3 - Sharing data between threads {#ch-3-sharing-data-between-threads}


### 3.1 Problems with sharing data between threads {#3-dot-1-problems-with-sharing-data-between-threads}


#### Race Conditions {#race-conditions}


#### Avoiding problematic race conditions {#avoiding-problematic-race-conditions}


### 3.2 Protecting shared data with mutexes {#3-dot-2-protecting-shared-data-with-mutexes}


#### Using mutexes in C++ {#using-mutexes-in-c-plus-plus}


#### Structuring code for protecting shared data {#structuring-code-for-protecting-shared-data}


#### Spotting race conditions inherent in interfaces {#spotting-race-conditions-inherent-in-interfaces}


#### Deadlock: the problem and a solution {#deadlock-the-problem-and-a-solution}


#### Further guidelines for avoiding deadlock {#further-guidelines-for-avoiding-deadlock}


#### Flexible locking with std::unique_lock {#flexible-locking-with-std-unique-lock}


#### Transferring mutex ownership between scopes {#transferring-mutex-ownership-between-scopes}


#### Locking at an appropriate granularity {#locking-at-an-appropriate-granularity}


### 3.3 Alternative facilities for protecting shared data {#3-dot-3-alternative-facilities-for-protecting-shared-data}


#### Protecting shared data during initialization {#protecting-shared-data-during-initialization}


#### Protecting rarely updated data structures {#protecting-rarely-updated-data-structures}


#### Recursive locking {#recursive-locking}


## Ch 4 - Synchronizing concurrent operations {#ch-4-synchronizing-concurrent-operations}


### 4.1 - Waiting for an event or other condition {#4-dot-1-waiting-for-an-event-or-other-condition}


#### Waiting for a condition with condition variables {#waiting-for-a-condition-with-condition-variables}


#### Building a thread-safe queue with condition variables {#building-a-thread-safe-queue-with-condition-variables}


### 4.2 - Waiting for one-off events with futures {#4-dot-2-waiting-for-one-off-events-with-futures}


#### Returning values from background tasks {#returning-values-from-background-tasks}


#### Associating a task with a future {#associating-a-task-with-a-future}


#### Making (std::)promises {#making--std--promises}


#### Saving an exception for the future {#saving-an-exception-for-the-future}


#### Waiting from multiple threads {#waiting-from-multiple-threads}


### 4.3 - Waiting with a time limit {#4-dot-3-waiting-with-a-time-limit}


#### Clocks {#clocks}


#### Durations {#durations}


#### Time points {#time-points}


#### Functions that accept timeouts {#functions-that-accept-timeouts}


### 4.4 - Using synchronization of operations to simplify code {#4-dot-4-using-synchronization-of-operations-to-simplify-code}


#### Functional programming with futures {#functional-programming-with-futures}


#### Synchronizing operations with message passing {#synchronizing-operations-with-message-passing}


#### Continuation-style concurrency with the Concurrency TS {#continuation-style-concurrency-with-the-concurrency-ts}


#### Chaining continuations {#chaining-continuations}


#### Waiting for more than one future {#waiting-for-more-than-one-future}


#### Waiting for the first future with a set with when_any {#waiting-for-the-first-future-with-a-set-with-when-any}


#### Latches and barriers in the Concurrency TS {#latches-and-barriers-in-the-concurrency-ts}


#### A basic latch type: std::experimental::latch {#a-basic-latch-type-std-experimental-latch}


#### std::experimental::barrier: a basic barrier {#std-experimental-barrier-a-basic-barrier}


#### std::experimental::flex_barrier - std::experimental::barrier's flexible friend {#std-experimental-flex-barrier-std-experimental-barrier-s-flexible-friend}


## Ch 5 - The C++ memory model and operations on atomic types {#ch-5-the-c-plus-plus-memory-model-and-operations-on-atomic-types}


### 5.1 - Memory model basics {#5-dot-1-memory-model-basics}


#### Objects and memory locations {#objects-and-memory-locations}


#### Objects, memory locations, and concurrency {#objects-memory-locations-and-concurrency}


#### Modification orders {#modification-orders}


### 5.2 - Atomic operations and types in C++ {#5-dot-2-atomic-operations-and-types-in-c-plus-plus}


#### The standard atomic types {#the-standard-atomic-types}


#### Operations on std::atomic_flag {#operations-on-std-atomic-flag}


#### Operations on std::atomic&lt;bool&gt; {#operations-on-std-atomic-bool}


#### Operations on std::atomic&lt;T\*&gt;: pointer arithmetic {#operations-on-std-atomic-t-pointer-arithmetic}


#### Operations on standard atomic integral types {#operations-on-standard-atomic-integral-types}


#### The std::atomic&lt;&gt; primary class template {#the-std-atomic-primary-class-template}


#### Free functions for atomic operations {#free-functions-for-atomic-operations}


### 5.3 - Synchronizing operations and enforcing ordering {#5-dot-3-synchronizing-operations-and-enforcing-ordering}


#### The synchronizes-with relationship {#the-synchronizes-with-relationship}


#### The happens-before relationship {#the-happens-before-relationship}


#### Memory ordering for atomic operations {#memory-ordering-for-atomic-operations}


#### Release sequences and synchronizes-with {#release-sequences-and-synchronizes-with}


#### Fences {#fences}


#### Ordering non-atomic operations with atomics {#ordering-non-atomic-operations-with-atomics}


#### Ordering non-atomic operations {#ordering-non-atomic-operations}


## Ch 6 - Designing lock-based concurrent data structures {#ch-6-designing-lock-based-concurrent-data-structures}


### 6.1 - What does it mean to design for concurrency? {#6-dot-1-what-does-it-mean-to-design-for-concurrency}


#### Guidelines for designing data structures for concurrency {#guidelines-for-designing-data-structures-for-concurrency}


### 6.2 - Lock-based concurrent data structures {#6-dot-2-lock-based-concurrent-data-structures}


#### A thread-safe stack using locks {#a-thread-safe-stack-using-locks}


#### A thread-safe queue using locks and condition variables {#a-thread-safe-queue-using-locks-and-condition-variables}


#### A thread-safe queue using find-grained locks and condition variables {#a-thread-safe-queue-using-find-grained-locks-and-condition-variables}


### 6.3 - Designing more complex lock-based data structures {#6-dot-3-designing-more-complex-lock-based-data-structures}


#### Writing a thread-safe lookup table using locks {#writing-a-thread-safe-lookup-table-using-locks}


#### Writing a thread-safe list using locks {#writing-a-thread-safe-list-using-locks}


## Ch 7 - Designing lock-free concurrent data structures {#ch-7-designing-lock-free-concurrent-data-structures}


### 7.1 - Definitions and consequences {#7-dot-1-definitions-and-consequences}


#### Types of non-blocking data structures {#types-of-non-blocking-data-structures}


#### Lock-free data structures {#lock-free-data-structures}


#### Wait-free data structures {#wait-free-data-structures}


#### The pros and cons of lock-free data structures {#the-pros-and-cons-of-lock-free-data-structures}


### 7.2 - Examples of lock-free data structures {#7-dot-2-examples-of-lock-free-data-structures}


#### Writing a thread-safe stack without locks {#writing-a-thread-safe-stack-without-locks}


#### Stopping those pesky leaks: managing memory in lock-free data structures {#stopping-those-pesky-leaks-managing-memory-in-lock-free-data-structures}


#### Detecting nodes in use with reference counting {#detecting-nodes-in-use-with-reference-counting}


#### Applying the memory model to the lock-free stack {#applying-the-memory-model-to-the-lock-free-stack}


#### Writing a thread-safe queue without locks {#writing-a-thread-safe-queue-without-locks}


### 7.3 - Guidelines for writing lock-free data structures {#7-dot-3-guidelines-for-writing-lock-free-data-structures}


#### Guideline: use std::memory_order_seq_cst for prototyping {#guideline-use-std-memory-order-seq-cst-for-prototyping}


#### Guideline: use a lock-free memory reclamation scheme {#guideline-use-a-lock-free-memory-reclamation-scheme}


#### Guideline: watch out for the ABA problem {#guideline-watch-out-for-the-aba-problem}


#### Guideline: identify busy-wait loops and help the other thread {#guideline-identify-busy-wait-loops-and-help-the-other-thread}


## Ch 8 - Designing concurrent code {#ch-8-designing-concurrent-code}


### 8.1 - Techniques for dividing work between threads {#8-dot-1-techniques-for-dividing-work-between-threads}


#### Dividing data between threads before processing begins {#dividing-data-between-threads-before-processing-begins}


#### Dividing data recursively {#dividing-data-recursively}


#### Dividing work by task type {#dividing-work-by-task-type}


### 8.2 - Factors affecting the performance for concurrent code {#8-dot-2-factors-affecting-the-performance-for-concurrent-code}


#### How many processors? {#how-many-processors}


#### Data contention and cache ping-pong {#data-contention-and-cache-ping-pong}


#### False sharing {#false-sharing}


#### How close is your data? {#how-close-is-your-data}


#### Over-subscription and excessive task switching {#over-subscription-and-excessive-task-switching}


### 8.3 - Designing data structures for multi-threaded performance {#8-dot-3-designing-data-structures-for-multi-threaded-performance}


#### Dividing array elements for complex operations {#dividing-array-elements-for-complex-operations}


#### Data access patterns in other data structures {#data-access-patterns-in-other-data-structures}


### 8.4 - Additional considerations when designing for concurrency {#8-dot-4-additional-considerations-when-designing-for-concurrency}


#### Exception safety in parallel algorithms {#exception-safety-in-parallel-algorithms}


#### Scalability and Amdahl's law {#scalability-and-amdahl-s-law}


#### Hiding latency with multiple threads {#hiding-latency-with-multiple-threads}


#### Improving responsiveness with concurrency {#improving-responsiveness-with-concurrency}


### 8.5 - Designing concurrent code in practice {#8-dot-5-designing-concurrent-code-in-practice}


#### A parallel implementation of std::for_each {#a-parallel-implementation-of-std-for-each}


#### A parallel implementation of std::find {#a-parallel-implementation-of-std-find}


#### A parallel implementation of std::partial_sum {#a-parallel-implementation-of-std-partial-sum}


## Ch 9 - Advanced thread management {#ch-9-advanced-thread-management}


### 9.1 - Thread pools {#9-dot-1-thread-pools}


#### The simplest possible thread pool {#the-simplest-possible-thread-pool}


#### Waiting for tasks submitted to a thread pool {#waiting-for-tasks-submitted-to-a-thread-pool}


#### Tasks that wait for other tasks {#tasks-that-wait-for-other-tasks}


#### Avoid contention on the work queue {#avoid-contention-on-the-work-queue}


#### Work stealing {#work-stealing}


### 9.2 - Interrupting threads {#9-dot-2-interrupting-threads}


#### Launching and interrupting another thread {#launching-and-interrupting-another-thread}


#### Detecting that a thread has been interrupted {#detecting-that-a-thread-has-been-interrupted}


#### Interrupting a condition variable wait {#interrupting-a-condition-variable-wait}


#### Interrupting a wait on std::condition_variable_any {#interrupting-a-wait-on-std-condition-variable-any}


#### Interrupting other blocking calls {#interrupting-other-blocking-calls}


#### Handling interruptions {#handling-interruptions}


#### Interrupting background tasks on application exit {#interrupting-background-tasks-on-application-exit}


## Ch 10 - Parallel algorithms {#ch-10-parallel-algorithms}


### 10.1 - Parallelizing the standard library algorithms {#10-dot-1-parallelizing-the-standard-library-algorithms}


### 10.2 - Execution policies {#10-dot-2-execution-policies}


#### General effects of specifying an execution policy {#general-effects-of-specifying-an-execution-policy}


#### std::execution::sequenced_policy {#std-execution-sequenced-policy}


#### std::execution::parallel_policy {#std-execution-parallel-policy}


#### std::execution::parallel_unsequenced_policy {#std-execution-parallel-unsequenced-policy}


### 10.3 - The parallel algorithms from the C++ Standard Library {#10-dot-3-the-parallel-algorithms-from-the-c-plus-plus-standard-library}


#### Examples of using parallel algorithms {#examples-of-using-parallel-algorithms}


#### Counting visits {#counting-visits}


## Ch 11 - Testing and debugging multi-threaded applications {#ch-11-testing-and-debugging-multi-threaded-applications}


### 11.1 - Types of concurrency-related bugs {#11-dot-1-types-of-concurrency-related-bugs}


#### Unwanted blocking {#unwanted-blocking}


#### Race conditions {#race-conditions}


### 11.2 - Techniques for locating concurrency-related bugs {#11-dot-2-techniques-for-locating-concurrency-related-bugs}


#### Reviewing code to locate potential bugs {#reviewing-code-to-locate-potential-bugs}


#### Locating concurrency-related bugs by testing {#locating-concurrency-related-bugs-by-testing}


#### Designing for test-ability {#designing-for-test-ability}


#### Multi-threaded testing techniques {#multi-threaded-testing-techniques}


#### Structuring multi-threaded test code {#structuring-multi-threaded-test-code}


#### Testing the performance of multi-threaded code {#testing-the-performance-of-multi-threaded-code}
